import pandas as pdimport numpy as npfrom dataclasses import dataclassfrom typing import Optional@dataclassclass BacktestConfig:    initial_capital: float = 100000    mode: str = "compounding"      # compounding / fixed    risk_per_trade: float = 0.01   # 1%    transaction_cost: float = 0.0005  # 0.05%    slippage: float = 0.0002       # 0.02%class BacktestEngineV2:    def __init__(self, strategy, config: BacktestConfig):        self.strategy = strategy        self.config = config        self.capital = config.initial_capital        self.equity_curve = []        self.trades = []        self.current_position = 0        self.entry_price = None        self.position_size = 0    # ---------------------------------------------------    # POSITION SIZING    # ---------------------------------------------------    def _calculate_position_size(self, price):        if self.config.mode == "compounding":            risk_capital = self.capital * self.config.risk_per_trade        else:            risk_capital = self.config.initial_capital * self.config.risk_per_trade        qty = risk_capital / price        return qty    # ---------------------------------------------------    # CORE BACKTEST LOOP    # ---------------------------------------------------    def run(self, df: pd.DataFrame):        df = self.strategy.generate_signals(df)        for i in range(len(df)):            row = df.iloc[i]            price = row["close"]            # ENTRY            if row.get("signal") == 1 and self.current_position == 0:                self.position_size = self._calculate_position_size(price)                self.entry_price = price                self.current_position = 1            # EXIT            elif row.get("signal") == -1 and self.current_position == 1:                pnl = (price - self.entry_price) * self.position_size                cost = abs(price * self.position_size) * self.config.transaction_cost                slip = abs(price * self.position_size) * self.config.slippage                pnl -= (cost + slip)                self.capital += pnl                self.trades.append({                    "entry": self.entry_price,                    "exit": price,                    "pnl": pnl,                    "capital": self.capital                })                self.current_position = 0                self.entry_price = None                self.position_size = 0            self.equity_curve.append(self.capital)        return self._generate_report()    # ---------------------------------------------------    # PERFORMANCE METRICS    # ---------------------------------------------------    def _generate_report(self):        equity = pd.Series(self.equity_curve)        returns = equity.pct_change().fillna(0)        total_return = (equity.iloc[-1] / equity.iloc[0]) - 1        max_dd = self._max_drawdown(equity)        sharpe = self._sharpe_ratio(returns)        profit_factor = self._profit_factor()        return {            "final_capital": self.capital,            "total_return": total_return,            "max_drawdown": max_dd,            "sharpe_ratio": sharpe,            "profit_factor": profit_factor,            "total_trades": len(self.trades)        }    def _max_drawdown(self, equity):        peak = equity.cummax()        dd = (equity - peak) / peak        return dd.min()    def _sharpe_ratio(self, returns):        if returns.std() == 0:            return 0        return (returns.mean() / returns.std()) * np.sqrt(252)    def _profit_factor(self):        profits = sum(t["pnl"] for t in self.trades if t["pnl"] > 0)        losses = abs(sum(t["pnl"] for t in self.trades if t["pnl"] < 0))        if losses == 0:            return 0        return profits / losses